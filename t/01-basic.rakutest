use v6.d;
use Test;

use BSON::Simple;

plan 1;


#| Round trip testing to a hex stringification of the BSON blob
multi matches(Mu $value, Str:D $bson) {
    matches($value, buf8.new($bson.comb(2).map(*.parse-base(16))))
}

#| Round trip testing directly to a BSON blob
multi matches(Mu $value, Buf:D $bson) {
    subtest "$value.raku() handled correctly", {
        my $as-bson  = bson-encode($value);
        my $as-value = bson-decode($bson);

        is-deeply $as-bson,  $bson,  "bson-encode produces correct blob";
        is-deeply $as-value, $value, "bson-decode produces correct value" if $value  ~~ Any;
        is        $as-value, Mu,     "bson-decode produces correct value" if $value !~~ Any;
    }
}


#| Unidirectional ENcoding testing, matching a hex stringification of the expected BSON blob
multi encodes-to(Mu $value, Str:D $bson) {
    encodes-to($value, buf8.new($bson.comb(2).map(*.parse-base(16))))
}

#| Unidirectional ENcoding testing, matching an expected BSON blob
multi encodes-to(Mu $value, Buf:D $bson) {
    my $as-bson = bson-encode($value);
    is-deeply $as-bson, $bson, "bson-encode({$value.raku}) produces correct blob"
}


#| Unidirectional DEcoding testing, from a hex stringification of the actual BSON blob
multi decodes-to(Mu $value, Str:D $bson) {
    decodes-to($value, buf8.new($bson.comb(2).map(*.parse-base(16))))
}

#| Unidirectional DEcoding testing, from an actual BSON blob
multi decodes-to(Mu $value, Buf:D $bson) {
    my $as-value = bson-decode($bson);
    my $as-hex   = $bson.map(*.fmt('%02X')).join;

    if $value ~~ Any {
        is-deeply $as-value, $value, "bson-decode($as-hex) produces correct value"
    }
    else {
        is        $as-value, $value, "bson-decode($as-hex) produces correct value"
    }
}


# Adapted from https://en.wikipedia.org/wiki/BSON#Example
matches { hello => 'world' }, '160000000268656C6C6F0006000000776F726C640000';



done-testing;

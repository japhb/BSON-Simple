#!/usr/bin/env raku

# NOTE: To test a structure pulled from a JSON file, you'll need a JSON test
#       file to work with.  I snapshotted mine from ~/.zef/store/360.zef.pm .


use JSON::Fast;
use CBOR::Simple;
use BSON::Simple;
use BSON::Document;


my @order  = < JSON::Fast CBOR::Simple BSON::Simple BSON::Document >;
my $length = @order.map(*.chars).max;


sub time-them(UInt:D $count, %by-codec) {
    my %times;
    my $runs = 1;
    for ^$runs {
        for @order -> $codec {
            my &test-code = %by-codec{$codec};
            my $ts = now;
            test-code() for ^$count;
            my $te = now;
            %times{$codec}.append($te - $ts);
        }
    }

    %times
}

sub show-times(Str:D $test, %times) {
    say "\n$test:";
    my $reference;
    for @order -> $codec {
        next unless %times{$codec} && my $fastest = %times{$codec}.min;
        if $reference {
            printf "%-{$length}s  %8.3fs (%.3fx)\n",
                   $codec, $fastest, $fastest / $reference;
        }
        else {
            printf "%-{$length}s  %8.3fs\n", $codec, $fastest;
            $reference = $fastest;
        }
    }
}

sub show-sizes(%sizes) {
    say "\nSizes:";
    my $reference;
    for @order -> $codec {
        next unless my $size = %sizes{$codec};
        if $reference {
            printf "%-{$length}s  %8d (%.3fx)\n",
                   $codec, $size, $size / $reference;
        }
        else {
            printf "%-{$length}s  %8d\n", $codec, $size;
            $reference = $size;
        }
    }
}

sub time-and-show(Str:D $test, UInt:D $count, %by-codec) {
    show-times($test, time-them($count, %by-codec));
}

sub time-codecs(Str:D $variant, UInt:D $count, $struct) {
    say "\n====> $variant <====";

    my $json = to-json     $struct, :!pretty;
    my $bson = bson-encode { b => $struct };
    my $cbor = cbor-encode $struct;

    my $doc  = BSON::Document.new($bson);
    my $doce = $doc.encode;

    my %sizes := {
        'JSON::Fast'     => $json.encode.bytes,
        'CBOR::Simple'   => $cbor.bytes,
        'BSON::Simple'   => $bson.bytes,
        'BSON::Document' => $doce.bytes,
    };
    show-sizes(%sizes);

    say "\nFidelity:";
    my $from-json = from-json   $json;
    my $from-cbor = cbor-decode $cbor;
    my $from-bson = bson-decode $bson;
    my $from-doce = BSON::Document.new($doce);
    say 'JSON::Fast          ', $from-json eqv $struct ?? 'pass' !! 'FAIL';
    say 'CBOR::Simple        ', $from-cbor eqv $struct ?? 'pass' !! 'FAIL';
    say 'BSON::Simple        ', $from-bson eqv $struct ?? 'pass' !! 'FAIL';
    say 'BSON::Document      ', $from-doce eqv $struct ?? 'pass' !! 'FAIL';

    time-and-show('Decode', $count,
                  {
                      'JSON::Fast'     => { my $j = from-json $json },
                      'CBOR::Simple'   => { my $c = cbor-decode $cbor },
                      'BSON::Simple'   => { my $b = bson-decode $bson },
                      'BSON::Document' => { my $d = BSON::Document.new($doce) },
                  });

    time-and-show('Encode', $count,
                  {
                      'JSON::Fast'     => { my $j = to-json $struct, :!pretty },
                      'CBOR::Simple'   => { my $c = cbor-encode $struct },
                      'BSON::Simple'   => { my $b = bson-encode { b => $struct } },
                      'BSON::Document' => { my $d = $doc.encode },
                  });
}


multi MAIN(UInt:D $count = 10, IO() $source = 'fez-test.json') {
    say "Testing $count iteration{$count == 1 ?? '' !! 's'}";

    my $json      = $source.slurp;
    my $from-json = from-json $json;
    time-codecs('JSON source', $count, $from-json);

    my $AoA-Int = [ [$++ xx 100] xx 100 ];
    time-codecs('100 x 100 Int array', $count, $AoA-Int);

    my $AoA-Num = [ [rand xx 100] xx 100 ];
    time-codecs('100 x 100 Num array', $count, $AoA-Num);

    my $AoA-Rat = [ [((^256).pick / (1..255).pick) xx 100] xx 100 ];
    time-codecs('100 x 100 small Rat array', $count, $AoA-Rat);

    my $buf8 = buf8.new((^256).roll(100_000));
    time-codecs('100_000 byte buf8', $count, $buf8);

    my $na32 = array[num32].new(rand xx 10_000);
    time-codecs('10_000 entry array[num32]', $count, $na32);

    my $na64 = array[num64].new(rand xx 10_000);
    time-codecs('10_000 entry array[num64]', $count, $na64);
}
